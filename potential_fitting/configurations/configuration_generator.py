from potential_fitting.molecule import xyz_to_molecules
from potential_fitting.utils import SettingsReader, utils
from potential_fitting.exceptions import ParsingError, LineFormatError
from random import randint, Random
import math, numpy
def generate_1b_configurations(settings_path, geo_path, normal_modes_path, config_path):
    """
    Generates a set of 1b configurations for a molecule given its optimized geometry and normal modes.

    Args:
        settings_path - path to the .ini file with relevant settings
        geo_path - path to the optimized geometry .xyz file
        normal_modes_path - path to normal modes file as generated by generate_normal_modes
        config_path - path to the file to write the configurations, existing content will be clobbered.
    """

    print("Parsing normal mode input file.")

    settings = SettingsReader(settings_path)

    # read the optimized geometry    
    molecule = xyz_to_molecules(geo_path, settings)[0]

    frequencies = []
    reduced_masses = []
    normal_modes = []

    # read frequencies, reduced masses, and normal modes from the input file.
    with open(normal_modes_path, "r") as normal_modes_file:

        # we loop until we run out of normal modes to parse
        while(True):
            first_line = normal_modes_file.readline()

            # if first line is empty string, we have reached EOF
            if first_line == "":
                break

            # if first line is not of valid format, raise error
            if not first_line.startswith("normal mode:") or not len(first_line.split()) == 3:
                raise LineFormatError(normal_modes_path, first_line, "EOF or normal mode: x")

            frequency_line = normal_modes_file.readline()

            # if the frequency line is not of valid format, raise error
            if frequency_line == "":
                raise ParsingError(normal_modes_path, "Unexpected EOF, expected line of format 'frequency = x'")

            if not frequency_line.startswith("frequency = ") or not len(frequency_line.split()) == 3:
                raise LineFormatError(normal_modes_path, frequency_line, "frequency = x")

            # parse the frequency from the frequency line
            try:
                frequency = float(frequency_line.split()[2])

            except ValueError:
                raise ParsingError(normal_modes_path, 
                        "cannot parse {} into a frequency float".format(frequecy_line.split()[2])) from None
            frequencies.append(frequency)

            reduced_mass_line = normal_modes_file.readline()

            # if the reduced mass line is not of valid format, raise error
            if reduced_mass_line == "":
                raise ParsingError(normal_modes_path, "Unexpected EOF, expected line of format 'recued mass = x'")

            if not reduced_mass_line.startswith("reduced mass = ") or not len(reduced_mass_line.split()) == 4:
                raise LineFormatError(normal_modes_path, reduced_mass_line, "reduced mass = x")

            # parse the reduced mass from the frequency line
            try:
                reduced_mass = float(reduced_mass_line.split()[3])

            except ValueError:
                raise ParsingError(normal_modes_path,
                        "cannot parse {} into a reduced mass float".format(reduced_mass_line.split()[3])) from None

            reduced_masses.append(reduced_mass)

            # parse the normal mode
            normal_mode = [[None, None, None] for i in range(molecule.get_num_atoms())]

            for atom_index in range(molecule.get_num_atoms()):
                normal_mode_line = normal_modes_file.readline()

                if normal_mode_line == "":
                    raise ParsingError(normal_modes_path, 
                            "Unexpected EOF, expected line of format 'x y z'")

                if len(normal_mode_line.split()) != 3:
                    raise LineFormatError(normal_modes_path, normal_mode_line,
                            "x y z")

                for ordinate_index, token in enumerate(normal_mode_line.split()):
                    try:
                        offset = float(token)

                    except ValueErrorL:
                        raise ParsingError(normal_modes_path,
                                "cannot parse {} into a offset float".format(token)) from None

                    normal_mode[atom_index][ordinate_index] = offset
                
            normal_modes.append(normal_mode)

            # skip the blank line
            blank_line = normal_modes_file.readline()
            if blank_line != "\n":
                raise ParsingError(normal_modes_path, "expected blank line")

    print("Frequencies:", frequencies)
    print("Reduced Masses:", reduced_masses)
    print("Normal Modes:", normal_modes)

    print("Completed parsing normal modes input file.")

    generate_1b_normal_mode_configs(settings_path, geo_path, frequencies, reduced_masses, normal_modes, config_path)

hbar = 1
bohr = 0.52917721092
autoeV = 27.211385
eVtoau = 3.674932379e-2
autocm = 2.194746313e5
autokcalmol = 627.5096
Ktoau = 3.1668114e-6
cmtoau = 4.5563352527e-6
melectron = 1822.88839
freq_cutoff = 10 * cmtoau

def generate_1b_normal_mode_configs(settings_path, geo_path, frequencies, reduced_masses, normal_modes, config_path, seed = randint(-100000, 100000), geometric = True):
    """
    NOTES/TODOS:
        * currently, highest frequency must be last, lowest frequency must be first
        * currently does not support imaginary frequencies
        * currently mutates the input arrays

    """

    # clear the output file
    with open(config_path, "w") as config_file:
        pass

    print("Running normal distribution configuration generator...")

    settings = SettingsReader(settings_path)

    molecule = xyz_to_molecules(geo_path, settings)[0]

    random = Random(seed)

    num_configs = settings.getint("config_generator", "num_configs")

    dim = 3 * molecule.get_num_atoms()
    dim_null = dim - len(normal_modes)

    num_A_configs = num_configs // 2
    num_temp_configs = num_configs - num_A_configs

    # mass-scale and normalize the normal modes
    for normal_mode in normal_modes:
        mass_scale = 0
        for coordinates, atom in zip(normal_mode, molecule.get_atoms()):
            coordinates = [ordinate * math.sqrt(atom.get_mass() * melectron) for ordinate in coordinates]
            mass_scale += coordinates[0] ** 2
            mass_scale += coordinates[1] ** 2
            mass_scale += coordinates[2] ** 2

        mass_scale = math.sqrt(mass_scale)

        for coordinates, atom in zip(normal_mode, molecule.get_atoms()):
            coordinates = [ordinate / mass_scale for ordinate in coordinates]

    # first generate the T distribution configs
    if geometric:
        temp_min = frequencies[0] / autocm # Kelvin
        temp_max = 2 * frequencies[len(frequencies) - 1] / autocm # Kelvin
        temp_factor = (temp_min / temp_max) ** (-1 / num_temp_configs)
        temp_addend = 0
    else:
        temp_min = 0 # Kelvin
        temp_max = frequencies[len(frequencies) - 1] / autocm # Kelvin
        temp_factor = 1
        temp_addend = (temp_max - temp_min) / num_temp_configs

    temp = temp_min
    for config_index in range(num_temp_configs):

        # generate a config
        G = [[0 for i in range(dim)] for k in range(dim)] # ???
        d = [0 for i in frequencies] # ???

        for normal_mode_index, frequency, reduced_mass, normal_mode in zip(range(len(frequencies)), frequencies, reduced_masses, normal_modes):
            if frequency < freq_cutoff:

                d[normal_mode_index] = 0

            else:

                # check if temp is significantly larger than zero
                if temp > 0.0e-8:
                    d[normal_mode_index] = 0.5 / (numpy.tanh(frequency / (2 * temp)) * frequency)

                # otherwise temp is about 0
                else:
                    d[normal_mode_index] = 0.5 / frequency

                for i in range(dim):
                    for j in range(dim):
                        G[i][j] += math.sqrt(d[normal_mode_index])*normal_mode[i // 3][i % 3]*normal_mode[j // 3][j % 3]

        # displacement from reference geometry
        displacement = [[0, 0, 0] for i in range(molecule.get_num_atoms())]

        # random_list = [random.random() for i in range(dim)]

        norm_dist_list = [random.normalvariate(0, 1) for i in range(dim)]

        for i in range(dim):
            displacement[i // 3][i % 3] = numpy.dot([g[i] for g in G], norm_dist_list)
            displacement[i // 3][i % 3] /= math.sqrt(molecule.get_atoms()[i // 3].get_mass() * melectron)

        with open(config_path, "a") as config_file:

            # write number of atoms
            config_file.write("{}\n".format(molecule.get_num_atoms()))

            # write index of this config in comment line
            config_file.write("{}\n".format(config_index))

            # write each atom
            for atom_index, atom in enumerate(molecule.get_atoms()):

                x = atom.get_x() + displacement[atom_index][0]
                y = atom.get_y() + displacement[atom_index][1]
                z = atom.get_z() + displacement[atom_index][2]

                config_file.write("{:2} {:22.14e} {:22.14e} {:22.14e}\n".format(atom.get_name(), x, y, z))

        # increase temp
        temp = temp * temp_factor + temp_addend

    # now generate the A distribution configs

    print("Normal Distribution Configuration generation complete.")
